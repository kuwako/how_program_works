# 1章: CPUとは何か
## 4つの要素からなる
- レジスタ
    - 処理対象となる命令やデータを格納する領域、メモリの一種
- 制御装置
    - メモリー上のデータや命令をレジスタに読み出し、命令の実行結果に応じてコンピュータ全体を制御する
- 演算装置
    - メモリーからレジスタに読み出されたデータを演算する
- クロック
    - CPUが動作するタイミングとなるクロック信号を発生させるもの

### なぜレジスタが重要なのか
- アセンブリ言語とマシン語が一対一に対応している
- 高水準言語で記述したプログラム→(コンパイル)アセンブリ言語に→(アセンブリ)マシン語に
- アセンブリ言語はレジスタを使って処理している
    - つまり、高水準言語で書いたプログラムは突き詰めていくとCPUのレジスタを使ってデータの格納、加算を行なっている

## レジスタ
- アキュムレータ
    - 演算を行うデータ
    - 演算の結果のデータを格納する
    - 基本1個
- フラグ・レジスタ
    - 演算処理後のCPUの状態を格納する
    - 基本一個
- プログラム・カウンタ
    - 次に実行される命令が格納されたメモリーのアドレスを格納する
    - 基本一個
- ベース・レジスタ
    - データ用のメモリ領域の先頭アドレスを格納する
- インデックス・レジスタ
    - ベース・レジスタからの相対アドレスを格納する
- 汎用レジスタ
    - 任意のデータを格納する
- 命令レジスタ
    - 命令そのものを格納する
    - 基本一個
- スタック・レジスタ
    - スタック領域の先頭アドレスを格納する
    - 基本一個

### レジスタに格納される値
- 命令
- データ
    - 演算に使われる値
    - メモリのアドレスを表している値
        - 値の種類により、格納するレジスタの種類が異なるので上記のように何種類ものレジスタがある

## プログラムの流れ
プログラムカウンタがプログラムの流れを決めていて、以下3種類の流れがある
- 順次実行
    - アドレスの値の順に命令を実行すること
- 条件分岐
    - 条件に応じて任意のアドレスの命令を実行すること
- 繰り返し
    - 同じアドレスの命令を何度か繰り返し実行すること

### 関数呼び出しの仕組み
関数呼び出しは単純なジャンプ命令ではない。なぜなら戻ってくる必要があるから。これを解決するのは
- コール命令
    - 関数の入り口アドレスをプログラム・カウンタに設定する前に関数呼び出しの次に実行すべき命令のアドレスをスタックに保存する
- リターン命令
    - スタックに保存されたアドレスをプログラムカウンタに設定する機能

### ベースとインデックスで配列を実現する
CPUはベースレジスタ+インデックスレジスタの値を実際に参照するメモリのアドレスと解釈する  
インデックスレジスタは配列における添字に相当する

### CPUにできることはいたって単純
- データ転送命令
    - レジスタとメモリ、レジスタと周辺装置の間でデータの読み書きをする
- 演算命令
    - アキュムレータで算術演算、論理演算、比較演算、シフト演算を行う
- ジャンプ命令
    - 分岐条件、繰り返し、無条件のジャンプ
- コール/リターン命令
    - 関数の呼び出し/呼び出し元へ戻る

# 2章: データを2進数でイメージする
## コンピュータが情報を2進数で取り扱う理由
- コンピュータはIC(集積回路)で構成されている  
- ICは2進数しか表現できない  
- bitはbinary digit(2進数)を略した言葉  

## シフト演算と乗除算の関係
### シフト演算
左に1シフトで2倍、右に1シフトで1/2倍になる
### コンピュータ処理に都合のいい「補数」
- 2進数でマイナスを表す一般的な方法は最上位桁を符号のために使うこと
    - 符号ビットが0の場合プラス、1の場合マイナス
- 2進数で-1は11111111
    - コンピュータは引き算を行う場合に内部的には足し算として演算する
    - そのため、マイナスを使うのには補数を使う
    - 補数を得るには、2進数で表された各桁の数値を反転し、その結果に1を加える

### 論理右シフトと算術右シフトの違い
- 論理右シフトは空いたケタには0を入れる
- 算術右シフトは正の数の場合は0、負の数の場合は1を入れる
- 論理シフトか算術シフトかを区別しないといけないのは、右シフトのみ。左シフトの場合は0を入れれば良い

### 論理演算をマスターするコツ
- 論理否定
    - 1なら0, 0なら1
- 論理積
    - 0,0か1,1なら1
- 論理和
    - どちらか/両方が1なら1
- 排他的論理和
    - 0,1か1,0なら1

# 第3章: コンピュータが少数点数の計算を間違える理由
### コンピュータが計算を間違う理由
- 0.1を100回加えても10にならない
    - 10進数の0.1は2進数で正確に表現できない
    - 1/3が10進数で正確に表現できないのと同じ

### 不動小数点とは
- 倍精度浮動小数点型整数
    - double
    - 64bit
    - 先頭1bit: 符号部
    - 次の11bit: 指数部
    - 次の52bit: 仮数部
- 単精度浮動小数点型整数
    - float
    - 32bit
    - 先頭1bit: 符号部
    - 次の8bit: 指数部
    - 次の23bit: 仮数部

#### 仮数部
小数点以上の値を1に固定する正規表現
- 元の数値をxとする
- xの整数部の一桁目が1になるように右シフト
- xの小数点以下を23bitにする
- xの小数点以下だけにして正規表現完成

#### 指数部 
イクセス表現 
- 指数部で表せる範囲の中央の値をゼロとみなすことで符号ビットをを使わないでマイナス値を表す工夫
- 11111111は10進数では255を示すが、イクセス表現では-127(2^7)をした128
- 01111111は10進数では127を示すが、イクセス表現では0を示す
- 00000000は10進数では0を示すが、イクセス表現では-127を示す

### コンピュータの計算間違いを回避するには
- 間違いを無視すること
    - 科学技術計算の分野では、一般的
- 先に整数で計算して割る
- BCD(Binary Coded Decimal)を使う
    - 4bitを使って0~9の数字1桁を表す方法
    - 計算誤差が許されない場合などは使用する

### 2進数と16進数
2進数は桁数が大きいので、プログラミング言語などでは16進数が使われる  
16進数は0xで始める

# 4章: 四角いメモリを丸く使う
### メモリの物理的な仕組みはシンプル
メモリ=メモリICの種類
- DRAM
- SRAM
- ROM

### メモリの論理的なイメージはビル
1KBのメモリなら1024階立てののビルディングとして表せる

### ポインタ
ポインタはデータが格納されているメモリのアドレスを持つ変数のこと  
ポインタに型があるのはポインタに格納されたアドレスから一度に何バイトのデータを読み書きするかを示すため  

### メモリを工夫して使うための基本は配列
#### スタック
- 後入れ先出し
    - 書き込み:push
    - 読み出し:pop
- stackとは草の山のこと、上に積んだら上から取って行く

#### キュー
- 先入れ先出し
    - 書き出し:enqueue
    - 読み出し:dequeue
- queueのことは待ち行列とも呼び、先に並んだ人から順番に呼ばれる
- リングバッファと呼ばれる

#### リスト
- 配列にデータを追加したり削除したりする処理を効率的に行える

#### 2分探索木
- 配列に格納されたデータを効率的に探索できる
- 配列に要素を追加するときにその大小関係を考慮して左右2つの方向に分岐させる




