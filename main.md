# 1章: CPUとは何か
## 4つの要素からなる
- レジスタ
    - 処理対象となる命令やデータを格納する領域、メモリの一種
- 制御装置
    - メモリー上のデータや命令をレジスタに読み出し、命令の実行結果に応じてコンピュータ全体を制御する
- 演算装置
    - メモリーからレジスタに読み出されたデータを演算する
- クロック
    - CPUが動作するタイミングとなるクロック信号を発生させるもの

### なぜレジスタが重要なのか
- アセンブリ言語とマシン語が一対一に対応している
- 高水準言語で記述したプログラム→(コンパイル)アセンブリ言語に→(アセンブリ)マシン語に
- アセンブリ言語はレジスタを使って処理している
    - つまり、高水準言語で書いたプログラムは突き詰めていくとCPUのレジスタを使ってデータの格納、加算を行なっている

## レジスタ
- アキュムレータ
    - 演算を行うデータ
    - 演算の結果のデータを格納する
    - 基本1個
- フラグ・レジスタ
    - 演算処理後のCPUの状態を格納する
    - 基本一個
- プログラム・カウンタ
    - 次に実行される命令が格納されたメモリーのアドレスを格納する
    - 基本一個
- ベース・レジスタ
    - データ用のメモリ領域の先頭アドレスを格納する
- インデックス・レジスタ
    - ベース・レジスタからの相対アドレスを格納する
- 汎用レジスタ
    - 任意のデータを格納する
- 命令レジスタ
    - 命令そのものを格納する
    - 基本一個
- スタック・レジスタ
    - スタック領域の先頭アドレスを格納する
    - 基本一個

### レジスタに格納される値
- 命令
- データ
    - 演算に使われる値
    - メモリのアドレスを表している値
        - 値の種類により、格納するレジスタの種類が異なるので上記のように何種類ものレジスタがある

## プログラムの流れ
プログラムカウンタがプログラムの流れを決めていて、以下3種類の流れがある
- 順次実行
    - アドレスの値の順に命令を実行すること
- 条件分岐
    - 条件に応じて任意のアドレスの命令を実行すること
- 繰り返し
    - 同じアドレスの命令を何度か繰り返し実行すること

### 関数呼び出しの仕組み
関数呼び出しは単純なジャンプ命令ではない。なぜなら戻ってくる必要があるから。これを解決するのは
- コール命令
    - 関数の入り口アドレスをプログラム・カウンタに設定する前に関数呼び出しの次に実行すべき命令のアドレスをスタックに保存する
- リターン命令
    - スタックに保存されたアドレスをプログラムカウンタに設定する機能

### ベースとインデックスで配列を実現する
CPUはベースレジスタ+インデックスレジスタの値を実際に参照するメモリのアドレスと解釈する  
インデックスレジスタは配列における添字に相当する

### CPUにできることはいたって単純
- データ転送命令
    - レジスタとメモリ、レジスタと周辺装置の間でデータの読み書きをする
- 演算命令
    - アキュムレータで算術演算、論理演算、比較演算、シフト演算を行う
- ジャンプ命令
    - 分岐条件、繰り返し、無条件のジャンプ
- コール/リターン命令
    - 関数の呼び出し/呼び出し元へ戻る

# 2章: データを2進数でイメージする
## コンピュータが情報を2進数で取り扱う理由
- コンピュータはIC(集積回路)で構成されている  
- ICは2進数しか表現できない  
- bitはbinary digit(2進数)を略した言葉  

## シフト演算と乗除算の関係
### シフト演算
左に1シフトで2倍、右に1シフトで1/2倍になる
### コンピュータ処理に都合のいい「補数」
- 2進数でマイナスを表す一般的な方法は最上位桁を符号のために使うこと
    - 符号ビットが0の場合プラス、1の場合マイナス
- 2進数で-1は11111111
    - コンピュータは引き算を行う場合に内部的には足し算として演算する
    - そのため、マイナスを使うのには補数を使う
    - 補数を得るには、2進数で表された各桁の数値を反転し、その結果に1を加える

### 論理右シフトと算術右シフトの違い
- 論理右シフトは空いたケタには0を入れる
- 算術右シフトは正の数の場合は0、負の数の場合は1を入れる
- 論理シフトか算術シフトかを区別しないといけないのは、右シフトのみ。左シフトの場合は0を入れれば良い

### 論理演算をマスターするコツ
- 論理否定
    - 1なら0, 0なら1
- 論理積
    - 0,0か1,1なら1
- 論理和
    - どちらか/両方が1なら1
- 排他的論理和
    - 0,1か1,0なら1

# 第3章: コンピュータが少数点数の計算を間違える理由
### コンピュータが計算を間違う理由
- 0.1を100回加えても10にならない
    - 10進数の0.1は2進数で正確に表現できない
    - 1/3が10進数で正確に表現できないのと同じ

### 不動小数点とは
- 倍精度浮動小数点型整数
    - double
    - 64bit
    - 先頭1bit: 符号部
    - 次の11bit: 指数部
    - 次の52bit: 仮数部
- 単精度浮動小数点型整数
    - float
    - 32bit
    - 先頭1bit: 符号部
    - 次の8bit: 指数部
    - 次の23bit: 仮数部

#### 仮数部
小数点以上の値を1に固定する正規表現
- 元の数値をxとする
- xの整数部の一桁目が1になるように右シフト
- xの小数点以下を23bitにする
- xの小数点以下だけにして正規表現完成

#### 指数部 
イクセス表現 
- 指数部で表せる範囲の中央の値をゼロとみなすことで符号ビットをを使わないでマイナス値を表す工夫
- 11111111は10進数では255を示すが、イクセス表現では-127(2^7)をした128
- 01111111は10進数では127を示すが、イクセス表現では0を示す
- 00000000は10進数では0を示すが、イクセス表現では-127を示す

### コンピュータの計算間違いを回避するには
- 間違いを無視すること
    - 科学技術計算の分野では、一般的
- 先に整数で計算して割る
- BCD(Binary Coded Decimal)を使う
    - 4bitを使って0~9の数字1桁を表す方法
    - 計算誤差が許されない場合などは使用する

### 2進数と16進数
2進数は桁数が大きいので、プログラミング言語などでは16進数が使われる  
16進数は0xで始める

# 4章: 四角いメモリを丸く使う
### メモリの物理的な仕組みはシンプル
メモリ=メモリICの種類
- DRAM
- SRAM
- ROM

### メモリの論理的なイメージはビル
1KBのメモリなら1024階立てののビルディングとして表せる

### ポインタ
ポインタはデータが格納されているメモリのアドレスを持つ変数のこと  
ポインタに型があるのはポインタに格納されたアドレスから一度に何バイトのデータを読み書きするかを示すため  

### メモリを工夫して使うための基本は配列
#### スタック
- 後入れ先出し
    - 書き込み:push
    - 読み出し:pop
- stackとは草の山のこと、上に積んだら上から取って行く

#### キュー
- 先入れ先出し
    - 書き出し:enqueue
    - 読み出し:dequeue
- queueのことは待ち行列とも呼び、先に並んだ人から順番に呼ばれる
- リングバッファと呼ばれる

#### リスト
- 配列にデータを追加したり削除したりする処理を効率的に行える

#### 2分探索木
- 配列に格納されたデータを効率的に探索できる
- 配列に要素を追加するときにその大小関係を考慮して左右2つの方向に分岐させる

# 5章: メモリとディスクの密接な関係
### メモリに読みださないと実行できない
ストアド・プログラム方式と呼ぶ  

### ディスクをメモリの一部として使う「仮想記憶」
- ページング方式
    - 実行されるプログラムを構造に関係なく一定の大きさの「ページ」に分割し、ページ単位でメモリとディスク間の置き換えを行う式
    - ページイン(読み出し)
    - ページアウト(書き出し)
    - 一般的なwindowsのページのサイズは4kb
    - ページングファイルを奥、ディスク上の仮想メモリは実メモリの同程度~2倍程度にするのが一般的
- セグメント方式
    - 実行されるプログラムを処理やデータの集合など意味のある単位にまとめたセグメントに分割し、セグメント単位でメモリとディスク間の置き換えを行う

### メモリを節約するプログラミング手法
- DLLファイルで関数を共有する
- stdcall呼び出しでプログラムのサイズを小さくする
    - C言語では、関数を呼び出した際に「スタックのクリーンアップ処理」が行われる
    - この「スタックのクリーンアップ処理」を何度も呼び出される関数の側で行うようにすれば呼び出す側で行う場合よりもプログラム全体のサイズを小さくできる
    - その際に使用するのがstdcall

### ディスクの物理構造
- セクター方式
    - 固定長の領域に区切る
    - windowsや一般的なハード・ディスクはこちらの方式
    - ディスクの表面を同心円上に区切った領域をトラックと呼び、トラックを固定長に区切った領域をセクターと呼ぶ
- バリアブル方式
    - 可変長の領域に区切る

#### セクター
- ディスクを読み書きする最小単位
- Windowsが論理的にディスクを読み書きする単位はセクターの数倍のクラスタ
- 1クラスタのサイズはハード・ディスクの容量に応じて512バイト,1KB,2KB...まである
- ディスクの容量が大きいほどクラスタのサイズが大きい
- どんな小さいファイルでも最低で1クラスタの領域を占有する

# 6章: 自分でデータを圧縮してみよう
### ファイルにはバイト単位で記録する
1byte = 8bit = 256種類

### ランレングス法の仕組み
AAAABBCCCをA4B2C3と繰り返しを見つけて圧縮することをランレングレス法と呼ぶ  
ランレングス法は文章など、連続の少ない形式では圧縮効率が悪い一方、画像のように色が連続するような場合には効果を発揮する

### モールス符号にハフマン法の基礎を見た
- LHA形式はハフマン法を応用している  
- モールス信号では、一般的な文章の中で出現頻度の高い文字ほど短い符号にしている
- ハフマン法では圧縮対象となるファイルごとに最適な符号体系を構築し、それを元に圧縮される

### 可逆圧縮と非可逆圧縮
- BMP以外のJPEG, TIFF, GIF等の形式は何らかの手法を使ってデータを圧縮している
- 画像の場合は圧縮後の画像ファイルを圧縮前の品質に戻す必要がない場合が多いので、非可逆な圧縮が行われることがある
    - JPEG: 非可逆圧縮なので、復元後の画像情報が一部欠落しうる
    - GIF: 可逆圧縮だが、256色しか使えないので、復元後の色情報が欠落してぼやけうる
    - TIFF: ぼやけないがオリジナルより大きいファイルサイズになりうる

# 7章: プログラムはどんな環境で動くのか
### ソースコードを簡単に利用できるFreeBSDのPorts
FreeBSDではPortsと呼ばれる、ソースを現在のハードウェアに合わせてコンパイルして、確実に動かせる仕組みがある

### エミュレータを使えば別の環境が手に入る
Virtual PC for MacというアプリでMac上でwindowsを動かせた  

### どこでも同じ実行環境を提供するJava仮想マシン
Java
- プログラミング言語としてのJava
- プログラミング実行環境としてのJava

コンパイル後に生成されるのは特定のCPUのネイティブコードではなく、バイトコードと呼ばれる  
バイトコードの実行環境をJava仮想マシン(JavaVM)と呼ぶ  
OSやハードウェアの機種に合わせてJavaVMを作成しておけば同じバイトコードのアプリケーションがどの環境でも動作する  

### BIOSとブートストラップ
BIOSはROMに記録され、あらかじめコンピュータ本体に内臓されているプログラム  
BIOSはキーボード、ディスク、グラフィックス・ボードなどの基本生業プログラムの他、「ブート・ストラップ・ローダー」を起動する機能を持っている  
コンピュータの電源を入れるとBIOSがハードウェアの正常動作を確認し、問題なければブート・ストラップ・ローダーを起動する  

# 8章: ソース・ファイルから実行可能ファイルができるまで
### コンピュータはネイティブコードしか実行できない
- C言語で書いても、コンパイルしてネイティブコードにする必要がある
- ネイティブコードはexeファイルなどをダウンプすることで見ることができる
- CPUの種類によって、ネイティブコードの種類も違う

### コンパイルだけでは実行可能ファイルが得られない
- コンパイルに続けて、リンクという処理が必要
- Cをコンパイルすると、オブジェクトファイルになっている
- オブジェクトファイルはネイティブコードになっているが、そのままでは実行できない
- 標準関数などが含まれるファイルを結合して1つのEXEファイルを生成するリンク処理をリンカー(リンケージ・エディタ、結合プログラム)に行ってもらう必要がある

### DLLファイルとインポートライブラリ
- WindowsではAPIのオブジェクトファイルが通常のライブラリファイルではなくDLLファイルに格納されている
- DLLファイルはプログラム実行時に結合される

### 実行可能ファイルの実行に必要なこと
- プログラム内の変数や関数がどこのメモリ・アドレスに配置されるかは実行するたびに異なる
- EXEファイル内では、変数や関数のメモリ・アドレスの値は仮のメモリ・アドレスが与えられており、プログラム実行時に実際のメモリ・アドレスに変換される=再配置情報
- EXEファイルが持つ再配置情報は変数や関数の相対アドレスになっている

### ロード時に作られるスタックとヒープ
スタック
- 関数の内部で一時的に使用されるローカル変数や、関数を呼び出すときの引数を格納するためのメモリ領域
- プログラマが明示的に行う必要はない

### ヒープ
- プログラム実行時に任意のデータやオブジェクトを格納するためのメモリ領域
- プログラマが記述したプログラムによって明示的に確保と解放を行う
- Cならmalloc関数で確保し、freeコマンドで解放される
- メモリの解放を意図的に行わないと、メモリリークになりシステムダウンに繋がる

# 9章: OSとアプリケーションの関係
### OSと高水準言語がハードウェアを抽象化してくれる
- OSが提供するシステムコールによって、プログラマはハードウェアを直接制御するプログラムを記述する必要がない
- OSと高水準言語によってハードウェアを抽象化できる

